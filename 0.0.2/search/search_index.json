{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Pydantic Units <p>Support for OpenMM units as pydantic fields</p> <p> </p> <p>The <code>pydantic-units</code> framework aims to offer a convenient way to work with OpenMM units in Pydantic models, in a way that is backwards compatible with both Pydantic v1 and v2. It is lightweight and has no dependencies beyond Pydantic and OpenMM.</p> <p>All units that are available in OpenMM are supported except for <code>'ampere'</code> whose symbol conflicts with the angstrom unit symbol, making parsing ambiguous. Angstroms can be specified as either <code>'A'</code>, or <code>'\u00c5'</code>.</p>"},{"location":"#installation","title":"Installation","text":"<p>This package can be installed using <code>conda</code> (or <code>mamba</code>, a faster version of <code>conda</code>):</p> <pre><code>mamba install -c conda-forge pydantic-units\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>The <code>OpenMMQuantity</code> class can be used as a field in a Pydantic model to represent a quantity with units. It will both handle parsing quantities with units from strings and checking that parsed units are compatible with the expected units.</p> <p>Quantities can either be passed into models (see below for how to define models) with such a field directly:</p> <pre><code>from openmm import unit\nMyModel(temperature=300.0 * unit.kelvin)\n</code></pre> <p>or they can be passed in as strings, in which case the unit can be specified either fully</p> <pre><code>MyModel(temperature='300.0 kelvin')\n</code></pre> <p>or with the unit symbol</p> <pre><code>MyModel(temperature='300.0 K')\n</code></pre> <p>The field also handles validation of the unit, so that the following will raise a validation error:</p> <pre><code>MyModel(temperature='300.0 A')\n# raises: Value error, invalid units angstrom - expected angstrom kelvin\n</code></pre>"},{"location":"#pydantic-v1","title":"Pydantic V1","text":"<p>Due to limitations of custom fields in Pydantic v1, v1 models must define a custom JSON encoder if the model needs to be serialised to JSON:</p> <pre><code>from pydantic import BaseModel\nfrom openmm import unit\n\nfrom pydantic_units import OpenMMQuantity, quantity_serializer\n\nclass Model(BaseModel):\n    class Config:\n        json_encoders = {unit.Quantity: quantity_serializer}\n\n    a: OpenMMQuantity[unit.angstrom]\n    b: OpenMMQuantity[unit.kelvin]\n\nmodel = Model(a=1.0 * unit.nanometer, b='298.0 K')\nmodel.json()\n# '{\"a\": \"10.0 A\", \"b\": \"298.0 K\"}'\n</code></pre>"},{"location":"#pydantic-v2","title":"Pydantic V2","text":"<p>Pydantic v2 supports custom fields with custom encoders, so the <code>OpenMMQuantity</code> field can be used directly in the model without needing to define a custom JSON encoder:</p> <pre><code>from pydantic import BaseModel\nfrom openmm import unit\n\nfrom pydantic_units import OpenMMQuantity\n\nclass Model(BaseModel):\n    a: OpenMMQuantity[unit.angstrom]\n    b: OpenMMQuantity[unit.kelvin]\n\nmodel = Model(a=1.0 * unit.nanometer, b='298.0 K')\nmodel.model_dump_json()\n# '{\"a\": \"10.0 A\", \"b\": \"298.0 K\"}'\n</code></pre> <p>Backwards compatibility with Pydantic v1 is also maintained:</p> <pre><code>from pydantic.v1 import BaseModel\nfrom openmm import unit\n\nfrom pydantic_units import quantity_serializer\nfrom pydantic_units.v1 import OpenMMQuantity\n\nclass Model(BaseModel):\n    class Config:\n        json_encoders = {unit.Quantity: quantity_serializer}\n\n    a: OpenMMQuantity[unit.angstrom]\n    b: OpenMMQuantity[unit.kelvin]\n\nmodel = Model(a=1.0 * unit.nanometer, b='298.0 K')\nmodel.json()\n# '{\"a\": \"10.0 A\", \"b\": \"298.0 K\"}'\n</code></pre>"},{"location":"#deserialization","title":"(De)Serialization","text":"<p>Quantity fields will be serialized into JSON as strings with the unit symbol, e.g.</p> <pre><code>from pydantic_units import quantity_serializer\nfrom openmm import unit\n\nprint(quantity_serializer(1.0 * unit.angstrom))\n# '1 A'\nprint(quantity_serializer(1.0 * unit.kilojoules_per_mole))\n# '1.0 kJ * mol**-1'\n</code></pre> <p>Likewise, when instantiating a field from a string (either through the constructor or through parsing JSON), the unit should be specified in the string as either the full unit name or the unit symbol:</p> <pre><code>from pydantic_units import quantity_validator\nfrom openmm import unit\n\nquantity_validator('1.0 angstrom', unit.angstrom)\n# Quantity(value=1.0, unit=angstrom)\nquantity_validator('1.0 A', unit.angstrom)\n# Quantity(value=1.0, unit=angstrom)\nquantity_validator('1.0 kJ/mol', unit.kilojoules_per_mole)\n# Quantity(value=1.0, unit=kilojoule/mole)\n</code></pre> <p>The leading <code>*</code> can be either included or omitted, and whitespace is usually ignored, such that the following are all equivalent:</p> <pre><code>from pydantic_units import quantity_validator\nfrom openmm import unit\n\nquantity_validator('1.0 A', unit.angstrom)\nquantity_validator('1.0A', unit.angstrom)\nquantity_validator('1.0 * A', unit.angstrom)\nquantity_validator('1.0*A', unit.angstrom)\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>To create a development environment, you must have <code>mamba</code> installed.</p> <p>A development conda environment can be created and activated with:</p> <pre><code>make env\nconda activate pydantic-units\n</code></pre> <p>To format the codebase:</p> <pre><code>make format\n</code></pre> <p>To run the unit tests:</p> <pre><code>make test\n</code></pre> <p>To serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#pydantic_units","title":"pydantic_units","text":"<p>Support for OpenMM units as pydantic fields</p> <p>Modules:</p> <ul> <li> <code>v1</code>           \u2013            <p>OpenMM Quantity type for Pydantic v1.</p> </li> <li> <code>v2</code>           \u2013            <p>OpenMM Quantity type for Pydantic v2.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>OpenMMQuantity</code>           \u2013            <p>A pydantic safe OpenMM quantity type that validates unit compatibility.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>quantity_serializer</code>             \u2013              <p>Serialize a Quantity to a string</p> </li> <li> <code>quantity_validator</code>             \u2013              <p>Validate a string or quantity as a quantity with expected units</p> </li> </ul>"},{"location":"reference/#pydantic_units.OpenMMQuantity","title":"OpenMMQuantity","text":"<p>               Bases: <code>Quantity</code></p> <p>A pydantic safe OpenMM quantity type that validates unit compatibility.</p>"},{"location":"reference/#pydantic_units.quantity_serializer","title":"quantity_serializer","text":"<pre><code>quantity_serializer(value: Quantity) -&gt; str\n</code></pre> <p>Serialize a Quantity to a string</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Quantity</code>)           \u2013            <p>The quantity to serialize</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The serialized string</p> </li> </ul> Source code in <code>pydantic_units/_common.py</code> <pre><code>def quantity_serializer(value: Quantity) -&gt; str:\n    \"\"\"Serialize a Quantity to a string\n\n    Args:\n        value: The quantity to serialize\n\n    Returns:\n        The serialized string\n    \"\"\"\n    unit = value.unit\n    value = value.value_in_unit(unit)\n\n    bases = list(reversed([*unit.iter_base_or_scaled_units()]))\n\n    components = [\n        (\n            None if i == 0 else \"*\",\n            base.symbol + (\"\" if exponent == 1 else f\"**{int(exponent)}\"),\n        )\n        for i, (base, exponent) in enumerate(bases)\n    ]\n\n    if unit == dimensionless:\n        components = []\n\n    unit_str = \" \".join(\n        v for component in components for v in component if v is not None\n    )\n    return f\"{value} {unit_str}\" if len(unit_str) &gt; 0 else f\"{value}\"\n</code></pre>"},{"location":"reference/#pydantic_units.quantity_validator","title":"quantity_validator","text":"<pre><code>quantity_validator(\n    value: str | Quantity, expected_units: Unit\n) -&gt; Quantity\n</code></pre> <p>Validate a string or quantity as a quantity with expected units</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>str | Quantity</code>)           \u2013            <p>The value to validate</p> </li> <li> <code>expected_units</code>               (<code>Unit</code>)           \u2013            <p>The expected units</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a valid quantity or has the wrong units</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Quantity</code>           \u2013            <p>The validated quantity.</p> </li> </ul> Source code in <code>pydantic_units/_common.py</code> <pre><code>def quantity_validator(value: str | Quantity, expected_units: Unit) -&gt; Quantity:\n    \"\"\"Validate a string or quantity as a quantity with expected units\n\n    Args:\n        value: The value to validate\n        expected_units: The expected units\n\n    Raises:\n        ValueError: If the value is not a valid quantity or has the wrong units\n\n    Returns:\n        The validated quantity.\n    \"\"\"\n    if isinstance(value, str):\n        value = _openmm_quantity_from_str(value)\n\n    assert isinstance(value, Quantity), f\"invalid type - {type(value)}\"\n\n    try:\n        return value.in_units_of(expected_units)\n    except TypeError as e:\n        raise ValueError(\n            f\"invalid units {value.unit} - expected {expected_units}\"\n        ) from e\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pydantic_units<ul> <li>v1</li> <li>v2</li> </ul> </li> </ul>"},{"location":"reference/v1/","title":"v1","text":""},{"location":"reference/v1/#pydantic_units.v1","title":"v1","text":"<p>OpenMM Quantity type for Pydantic v1.</p> <p>Classes:</p> <ul> <li> <code>OpenMMQuantity</code>           \u2013            <p>A pydantic safe OpenMM quantity type that validates unit compatibility.</p> </li> </ul>"},{"location":"reference/v1/#pydantic_units.v1.OpenMMQuantity","title":"OpenMMQuantity","text":"<p>               Bases: <code>Quantity</code></p> <p>A pydantic safe OpenMM quantity type that validates unit compatibility.</p>"},{"location":"reference/v2/","title":"v2","text":""},{"location":"reference/v2/#pydantic_units.v2","title":"v2","text":"<p>OpenMM Quantity type for Pydantic v2.</p> <p>Classes:</p> <ul> <li> <code>OpenMMQuantity</code>           \u2013            <p>A pydantic safe OpenMM quantity type that validates unit compatibility.</p> </li> </ul>"},{"location":"reference/v2/#pydantic_units.v2.OpenMMQuantity","title":"OpenMMQuantity","text":"<p>               Bases: <code>Quantity</code></p> <p>A pydantic safe OpenMM quantity type that validates unit compatibility.</p>"}]}